// This code was generated by a compiler from demos/arena.lang
// http://github.com/anthony-y/compiler
typedef signed   char s8;
typedef unsigned char u8;
typedef signed   short s16;
typedef unsigned short u16;
typedef signed   int s32;
typedef unsigned int u32;
typedef signed   long int s64;
typedef unsigned long int u64;
typedef float  f32;
typedef double f64;
typedef struct string {u8 *data; u64 length;} string;
typedef enum bool {false, true} bool;
#define cast 
#define NULL (void *)0

void __global_initializers();
static inline string __make_string(u8 *data, u64 length) {
    return (string){.data=data, .length=length};
}

struct Arena;
void __Arena_initer(struct Arena*);
void compiler_main();
u8* arena_alloc(struct Arena* a, u64 size);
bool arena_maybe_grow(struct Arena* a, u64 desired_size);
void puts(u8* s);
void free(void* ptr);
void* malloc(u64 size);
void realloc(void* ptr, u64 size);
void printf(u8* fmt, ...);
void memcpy(void* dest, void* src, u64 n);
struct Arena {
u8* mem;
bool fixed;
int cursor;
int capacity;
};

void __Arena_initer(struct Arena* s) {
s->fixed = false;
s->cursor = 0;
s->capacity = 1024;
}

void __compiler_main() {
__global_initializers();
struct Arena arena;
__Arena_initer(&arena);
arena.mem = malloc(arena.capacity);
// defer'd statement;
u8* c_string = arena_alloc(&arena, 8);
memcpy(c_string, __make_string("%s", 2).data, __make_string("%s", 2).length);
printf(c_string, __make_string("Anthony\n", 9).data);
free(arena.mem);
}
u8* arena_alloc(struct Arena* a, u64 size) {
if (!arena_maybe_grow(a, size)) {
return NULL;
};
u8* ret = a->mem+a->cursor;
a->cursor += size;
return ret;
}
bool arena_maybe_grow(struct Arena* a, u64 desired_size) {
if ((a->cursor+desired_size)>a->capacity) {
if (a->fixed) {
puts(__make_string("Out of space :(", 15).data);
return false;
;
};
a->capacity *= 2;
realloc(a->mem, a->capacity);
return true;
;
};
}

void __global_initializers() {
}
int main(int __argcount, char *__args[]) {
__compiler_main();
}
