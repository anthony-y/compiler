type Arena: struct {
	fixed    := false;
	cursor   := 0;
	capacity := 1024;
	mem: ^u8;
}

msg := "Arena allocator\n";
len := msg.length;

proc main() {
	arena: Arena;
	arena.mem = alloc(arena.capacity);
	defer free(arena.mem);

	bytes := arena_alloc(^arena, len+1);
	mem_copy(bytes, msg.data, len);
	bytes[len] = 0;

	print("%s".data, bytes);
}

proc arena_alloc(a: ^Arena, size: u64): ^u8 {
	if !arena_maybe_grow(a, size) then return null;
	ret := a.mem + a.cursor;
	a.cursor += size;
	return ret;
}

proc arena_maybe_grow(a: ^Arena, desired_size: u64): bool {
	if a.fixed {
		puts("Out of space :(".data);
		return false;
	}

	if (a.cursor + desired_size) > a.capacity {
		a.capacity *= 2;
		a.mem = realloc(a.mem, a.capacity);
	}

	return true;
}

proc puts(s: ^u8) #foreign;
proc free(ptr: ^void) #foreign;
proc alloc(size: u64): ^void #foreign "malloc";
proc realloc(ptr: ^void, size: u64): ^void #foreign;
proc print(fmt: ^u8, args: []any..) #foreign "printf";
proc mem_copy(dest: ^void, src: ^void, n: u64) #foreign "memcpy";
