Check binary maths
Dereference
Check if the casts expression can even be casted to the requested type
Check if branches
Check while loops

Call modifiers e.g: a := inline some_call()
    inline is added to lexer

Change AstBinary stmt to AstAssignment

Alias checking bug on calls

//
// AST
//
Fix the subtree allocator leak.

//
// Checker
//

Anonymous structs

Check in typedef'd structs that they don't mention their own names unless it's a pointer.

Check that procs with return types have return statements.

When local procedures are implemented, proc calls will need to be checked using lookup_local or something else.

//
// Syntax
//

Allocate and zero out syntax
t: *T = alloct(1){0};

    proc mod_i_val_and_ref(const* i: ^int) {
        // const* means: you cannot modify either the reference itself, or dereference it, obviously only applies for pointer types
        // should the * indicate the allowance OR disallowance of dereferencing?
        *i = 10 // error
        i = null // error
    }

    proc mod_i_val(const i: ^int) {
        *i = 100 // valid
        i = null; // error
    }

    proc main() {
        const i : ^int = null;
        mod_i3(i)
    }

    proc mod_i3(i: ^int) {
        i = 10 // error at call site: "mod_i3" modifies argument "i", but it was passed as a constant decl
    }

Enum composition
