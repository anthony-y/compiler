string members
    s := "blah"
    s.data = null

Anon structs access arrays are broken (check.lang)
Disallow pointers to anonymous struct types e.g:
    t: ^struct{a: int};

Check if the casts expression can even be casted to the requested type

When adding local procedures, make sure the non-local ones get their flags set as DECL_IS_TOP_LEVEL.

//
// Syntax
//

Call modifiers e.g: a := inline some_call()
    inline is added to lexer

Allocate and zero out syntax
    t: *T = alloct(1){0};

Const semantics
    proc val_and_ref_are_const(const i: ^int) {
        // const means: you cannot modify either the reference itself, or dereference it on the LHS of an assignment, obviously only applies for pointer types
        *i = 10 // error
        i = null // error
    }

    proc ref_is_constant(const* i: ^int) {
        // const* means you cannot modify the pointer itself, but you can modify the value that the pointer points to.
        *i = 100 // valid
        i = null; // error
    }

    proc main() {
        const my_int_ptr : ^int = null;
        passing_a_const(my_int_ptr) // error "passing_a_const" modifies argument "i" (my_int_ptr), but it was passed as a constant declaration
    }

    proc passing_a_const(i: ^int) {
        *i = 10 // if i is passed as a const declaration, error
        i = null // the pointer itself is copied into the new scope, so this is valid
    }

Enum composition

//
// Checker
//

When local procedures are implemented, proc calls will need to be checked using lookup_local or something else.
