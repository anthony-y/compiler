Parse assignments
    Didn't consider arbitrary expressions on lhs before
        Need to reimplement

Check binary maths
Check if the casts expression can even be casted to the requested type
Check if branches
Check while loops

Change AstBinary stmt to AstAssignment

Call modifiers e.g: a := inline some_call()
    inline is added to lexer

//
// Checker
//

When local procedures are implemented, proc calls will need to be checked using lookup_local or something else.

//
// Syntax
//

Allocate and zero out syntax
    t: *T = alloct(1){0};

Const semantics
    proc val_and_ref_are_const(const i: ^int) {
        // const means: you cannot modify either the reference itself, or dereference it on the LHS of an assignment, obviously only applies for pointer types
        *i = 10 // error
        i = null // error
    }

    proc ref_is_constant(const* i: ^int) {
        // const* means you cannot modify the pointer itself, but you can modify the value that the pointer points to.
        *i = 100 // valid
        i = null; // error
    }

    proc main() {
        const my_int_ptr : ^int = null;
        passing_a_const(my_int_ptr) // error "passing_a_const" modifies argument "i" (my_int_ptr), but it was passed as a constant declaration
    }

    proc passing_a_const(i: ^int) {
        *i = 10 // if i is passed as a const declaration, error
        i = null // the pointer itself is copied into the new scope, so this is valid
    }

Enum composition
