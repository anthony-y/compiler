Array indexes inside compound expressions (e.g: a.b[0].z)


Type resolution for binary expressions, specifically maths. Just returning type of left or right side
wont work out. Check the resolved type of binary exprs if mystery bugs (errors or lack thereof) show up.

Check if the casts expression can even be casted to the requested type

//
// Syntax
//

Call modifiers e.g: a := inline some_call()
    inline is added to lexer

Allocate and zero out syntax
    t: *T = alloct(1){0};

Const semantics
    proc val_and_ref_are_const(const i: ^int) {
        // const means: you cannot modify either the reference itself, or dereference it on the LHS of an assignment, obviously only applies for pointer types
        *i = 10 // error
        i = null // error
    }

    proc ref_is_constant(const* i: ^int) {
        // const* means you cannot modify the pointer itself, but you can modify the value that the pointer points to.
        *i = 100 // valid
        i = null; // error
    }

    proc main() {
        const my_int_ptr : ^int = null;
        passing_a_const(my_int_ptr) // error "passing_a_const" modifies argument "i" (my_int_ptr), but it was passed as a constant declaration
    }

    proc passing_a_const(i: ^int) {
        *i = 10 // if i is passed as a const declaration, error
        i = null // the pointer itself is copied into the new scope, so this is valid
    }

Enum composition

//
// Checker
//

When local procedures are implemented, proc calls will need to be checked using lookup_local or something else.
