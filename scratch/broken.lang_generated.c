// This code was generated by a compiler from scratch/broken.lang
// http://github.com/anthony-y/compiler
typedef signed   char s8;
typedef unsigned char u8;
typedef signed   short s16;
typedef unsigned short u16;
typedef signed   int s32;
typedef unsigned int u32;
typedef signed   long int s64;
typedef unsigned long int u64;
typedef float  f32;
typedef double f64;
typedef struct string {u8 *data; u64 length;} string;
typedef enum bool {false, true} bool;
#define cast 
#define NULL (void *)0

void __global_initializers();
static inline string __make_string(u8 *data, u64 length) {
    return (string){.data=data, .length=length};
}

void free(void* p);
void printf(string s);
void compiler_main();
struct Lexer;
bool lexer_init(struct Lexer* l, string ss);
int Token_EOF;
struct Lexer {
    u8* curr;
    u8* start;
    u64 line;
    u32 column;
    int last;
    struct {
    u8* block;
    int cap;
    int len;
}  string_allocator;
} ;

void free(void* p) {
}
void printf(string s) {
}
void __compiler_main() {
    __global_initializers();
    int i = 2;
    bool a = true;
    if (!a) {
        printf(__make_string("Incorrect number of arguments.\n", 32));
        return;
    }else if (1) {
        return 1;
    };
    string file_data = __make_string("", 0);
    struct Lexer* lexer = NULL;
    lexer_init(lexer, file_data);
    free(lexer);
    return;
}
bool lexer_init(struct Lexer* l, string ss) {
    l->curr = ss.data;
    l->start = ss.data;
    l->line = 1;
    l->column = 1;
    l->last = Token_EOF;
    return true;
}

void __global_initializers() {
    Token_EOF = 0;
}
int main(int __argcount, char *__args[]) {
    __compiler_main();
}
