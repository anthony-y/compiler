// The final step in compilation, the now known-to-be-correct ASTs are fed into the code generator to produce C output, which is given to a C compiler to generate the binary.
#include "headers/passes.h"
#include "headers/context.h"
#include "headers/ast.h"
#include "headers/type.h"
#include "headers/arena.h"

#include "headers/stb/stb_ds.h"

#include <stdio.h>
#include <string.h>
#include <assert.h>

#define BUFFER_SIZE 1024

static FILE *output = NULL;

#if 1
struct String {
    char *data;
    u64 length;
};

struct Buffer {
    char data[BUFFER_SIZE];
    u64 length = 0;
    Buffer *next;
};

struct Builder {
    Buffer *first_buffer   = NULL;
    Buffer *current_buffer = NULL;
    u64 total_length = 0;
};

void init_builder(Builder *b) {
    b->first_buffer   = (Buffer *)malloc(sizeof(Buffer));
    b->current_buffer = b->first_buffer;
}

void append(Builder *b, Token t) {
    if (b->current_buffer->length + t.length > BUFFER_SIZE) {
        auto newbuf = (Buffer *)malloc(sizeof(Buffer));
        b->current_buffer->next = newbuf;
        b->current_buffer = newbuf;
    }

    memcpy(b->current_buffer->data + b->current_buffer->length, t.text, t.length);
    b->current_buffer->length += t.length;
    b->total_length += t.length;
}

String to_string(const Builder b) {
    Buffer *buf = b.first_buffer;

    String out;
    out.data   = (char *)malloc(b.total_length);
    out.length = b.total_length;

    while (buf) {
        memcpy(out.data, buf->data, buf->length);
        buf = buf->next;
    }

    out.data[out.length] = 0;

    return out;
}


static void emit_boilerplate(const char *file_name) {
    fprintf(output, "// This code was generated by a compiler, from %s\n", file_name);
    fprintf(output, "// http://github.com/anthony-y/compiler\n");
    fprintf(output, "typedef signed   char s8;\n");
    fprintf(output, "typedef unsigned char u8;\n");
    fprintf(output, "typedef signed   short s16;\n");
    fprintf(output, "typedef unsigned short u16;\n");
    fprintf(output, "typedef signed   int s32;\n");
    fprintf(output, "typedef unsigned int u32;\n");
    fprintf(output, "typedef signed   long int s64;\n");
    fprintf(output, "typedef unsigned long int u64;\n");
    fprintf(output, "typedef float  f32;\n");
    fprintf(output, "typedef double f64;\n");
    fprintf(output, "typedef struct string {u8 *data; u64 length;} string;\n");
    fprintf(output, "typedef enum bool {false, true} bool;\n");
    fprintf(output, "#define cast \n");
    fprintf(output, "#define NULL (void *)0\n");
    fprintf(output, "\n");
    fprintf(output, "void __global_initializers();\n");
    fprintf(output, "static inline string __make_string(u8 *data, u64 length) {\n");
    fprintf(output, "    return (string){.data=data, .length=length};\n");
    fprintf(output, "}\n");
    fprintf(output, "\n");
}

static void emit_c_for_type(AstTypeDecl *t) {
    switch (t->expr_type) {
    case TypeDecl_STRUCT:
        fprintf(output, "struct %s", t->name->text);
        break;
    case TypeDecl_ENUM:
        fprintf(output, "enum %s", t->name->text);
        break;
    case TypeDecl_PROCEDURE: {
        auto proc = t->proc;
        emit_c_for_type(proc->return_type->resolved_type);
        fprintf(output, "(*%s)(", (t->name ? t->name->text : ""));
        for (u64 i = 0; i < proc->argument_types.len; i++) {
            emit_c_for_type(((AstTypename *)proc->argument_types.nodes[i])->resolved_type);
            if (i < proc->argument_types.len-1) fprintf(output, ",");
        }
        fprintf(output, ")");
    } break;
    case TypeDecl_INTEGER:
    case TypeDecl_FLOAT:
    case TypeDecl_BOOL:
    case TypeDecl_VOID:
    case TypeDecl_STRING:
        fprintf(output, "%s", t->name->text);
        break;
    case TypeDecl_POINTER:
        emit_c_for_type(t->base_type);
        fprintf(output, "*");
        break;
    case TypeDecl_ARRAY:
        emit_c_for_type(t->base_type);
        fprintf(output, "*");
        // TODO
        break;
    default: printf("idk what to do\n");
    }
}

static void emit_c_for_expr(AstExpr *expr);
static void emit_c_for_stmt(AstNode *stmt);
static void emit_c_for_struct(AstStruct *def, char *name);

static void emit_deferred_stmts(AstBlock *block) {
    for (int i = block->deferred->len-1; i >= 0; i--) {
        AstNode *node = block->deferred->nodes[i];
        emit_c_for_stmt(node);
        fprintf(output, ";\n");
    }
    if (block->parent) emit_deferred_stmts(block->parent);
}

static void emit_c_for_call(AstCall *call) {
    /*
    if (call->name->as.name == name_for_main) {
        fprintf(output, "__compiler_main()");
        return;
    }
    */
    if (call->calling->foreign_link_name) {
        Token t = call->calling->foreign_link_name->token;
        fprintf(output, "%s(", t.text);
    } else {
        if (call->name->tag == Node_BINARY) {
            AstBinary *selector = (AstBinary *)call->name;
            assert(selector->right->tag == Node_IDENT);
            auto ident = (AstIdent *)selector->right;
            fprintf(output, "%s(", ident->name->text);
        } else if (call->name->tag == Node_IDENT) {
            auto ident = (AstIdent *)call->name;
            fprintf(output, "%s(", ident->name->text);
        }
    }
    if (call->params) {
        for (u64 i = 0; i < call->params->len; i++) {
            emit_c_for_expr((AstExpr *)call->params->nodes[i]);
            if (i < call->params->len-1) {
                fprintf(output, ", ");
            }
        }
    }
    fprintf(output, ")");
}

static void emit_c_for_expr(AstExpr *expr) {
    Token t = expr->token;
    switch (expr->tag) {
    case Node_STRING_LIT:
        // -2 because quotes are counted in the length of the token.
        // TODO fix this at lexer level.
        fprintf(output, "__make_string(\"%s\", %d)", t.text, t.length-2);
        return;
    case Node_NULL_LIT:
        fprintf(output, "NULL");
        return;
    case Node_CALL:
        emit_c_for_call((AstCall *)expr);
        return;
    case Node_BOOL_LIT: {
        bool val = ((AstLiteral *)expr)->boolean;
        fprintf(output, val ? "true" : "false");
        return;
    } break;
    case Node_INDEX: {
        AstArrayIndex *i = (AstArrayIndex *)expr;
        emit_c_for_expr(i->name);
        fprintf(output, "[");
        emit_c_for_expr(i->index);
        fprintf(output, "]");
    } break;
    case Node_BINARY: {
        AstBinary *binary = (AstBinary *)expr;
        if (binary->left->resolved_type->expr_type == TypeDecl_ENUM) {
            auto name = (AstIdent *)binary->right;
            fprintf(output, "%s__%s", binary->left->resolved_type->name->text, name->name->text);
            return;
        }
        emit_c_for_expr(binary->left);
        switch (binary->op) {
        case Token_AMP_AMP: fprintf(output, "&&"); break;
        case Token_BAR_BAR: fprintf(output, "||"); break;
        case Token_LESS: fprintf(output, "<"); break;
        case Token_GREATER: fprintf(output, ">"); break;
        case Token_BANG_EQUAL: fprintf(output, "!="); break;
        case Token_GREATER_EQUAL: fprintf(output, ">="); break;
        case Token_LESS_EQUAL: fprintf(output, "<="); break;
        case Token_EQUAL_EQUAL: fprintf(output, "=="); break;
        case Token_PLUS: fprintf(output, "+"); break;
        case Token_MINUS: fprintf(output, "-"); break;
        case Token_SLASH: fprintf(output, "/"); break;
        case Token_STAR: fprintf(output, "*"); break;
        case Token_EQUAL: fprintf(output, "="); break;
        case Token_PLUS_EQUAL: fprintf(output, "+="); break;
        case Token_MINUS_EQUAL: fprintf(output, "-="); break;
        case Token_STAR_EQUAL: fprintf(output, "*="); break;
        case Token_SLASH_EQUAL: fprintf(output, "/="); break;
        case Token_DOT: {
            if (binary->left->resolved_type->expr_type == TypeDecl_POINTER)
                fprintf(output, "->");
            else
                fprintf(output, ".");
        } break;
        default: assert(false);
        }
        emit_c_for_expr(binary->right);
        return;
    } break;
    case Node_UNARY: {
        AstUnary *unary = (AstUnary *)expr;
        switch (unary->op) {
        case Token_MINUS: fprintf(output, "-"); break;
        case Token_CARAT: fprintf(output, "&"); break;
        case Token_STAR: fprintf(output, "*"); break;
        case Token_BANG: fprintf(output, "!"); break;
        default: assert(false);
        }
        emit_c_for_expr(unary->expr);
        return;
    } break;
    case Node_PAREN:
        fprintf(output, "(");
        emit_c_for_expr(((AstParen *)expr)->sub_expr);
        fprintf(output, ")");
        return;
    case Node_CAST: {
        AstCast *cast = (AstCast *)expr;
        fprintf(output, "(cast(");
        emit_c_for_type(cast->type->resolved_type);
        fprintf(output, ")");
        emit_c_for_expr(cast->expr);
        fprintf(output, ")");
        return;
    } break;

    default: break;
    }
    fprintf(output, "%.*s", t.length, t.text);
}

static void emit_c_for_local_decl(AstDecl *decl) {
    if (decl->status == Status_UNRESOLVED) return;
    if (decl->tag == Node_TYPE_DECL) return;
    if (decl->expr && decl->expr->tag == Node_PROCEDURE) return;

    emit_c_for_type(decl->given_type->resolved_type);
    fprintf(output, " %s", decl->name->text);

    auto realtype = decl->given_type->resolved_type;

    if (decl->expr) {
        fprintf(output, " = ");
        emit_c_for_expr(decl->expr);
    }

    if (realtype->expr_type == TypeDecl_STRUCT) {
        fprintf(output, ";\n__%s_initer(&%s);\n", realtype->name->text, decl->name->text);
    } else if (realtype->expr_type == TypeDecl_POINTER && realtype->base_type->expr_type == TypeDecl_STRUCT) {
        fprintf(output, ";\n__%s_initer(%s);\n", realtype->base_type->name->text, decl->name->text);
    }
}

static void emit_c_for_stmt(AstNode *stmt) {
    switch (stmt->tag) {
    case Node_DEFER:
        // No code is generated for a defer
        // they are accumulated during the resolution phase
        // and then at the end of a block, the deferred
        // statements are appended in reverse order.
        fprintf(output, "// defer'd statement");
        return;
    case Node_DECL:
        emit_c_for_local_decl((AstDecl *)stmt);
        break;
    case Node_CALL: {
		auto call = (AstCallStmt *)stmt;
		emit_c_for_call(call->expr);
	} break;
    case Node_ASSIGN: {
        auto assign = (AstAssignment *)stmt;
        emit_c_for_expr(assign->expr);
    } break;
    case Node_BLOCK: {
        AstBlock *block = (AstBlock *)stmt;
        for (u64 i = 0; i < block->statements->len; i++) {
            emit_c_for_stmt(block->statements->nodes[i]);
            fprintf(output, ";\n");
        }
    } break;
    case Node_IF: {
        // if (/*condition*/) {
        //   ...           
        // }
        AstIf *iff = (AstIf *)stmt;
        fprintf(output, "if (");
        emit_c_for_expr(iff->condition);
        fprintf(output, ") {\n");
        emit_c_for_stmt((AstNode *)iff->block_or_stmt);
        fprintf(output, ";\n");
        fprintf(output, "}");

        if (iff->other_branch) {
            fprintf(output, "else ");
            if (iff->other_branch->tag == Node_BLOCK) {
                fprintf(output, "{\n");
                emit_c_for_stmt((AstNode *)iff->other_branch);
                fprintf(output, "}");
            } else {
                emit_c_for_stmt((AstNode *)iff->other_branch);
            }
        }
    } break;
    case Node_WHILE: {
        AstWhile *w = (AstWhile *)stmt;
        fprintf(output, "while (");
        emit_c_for_expr(w->condition);
        fprintf(output, ") {\n");
        emit_c_for_stmt((AstNode *)w->block);
        fprintf(output, "}");
    } break;
    case Node_RETURN: {
        AstReturn *ret = (AstReturn *)stmt;
        emit_deferred_stmts(ret->owning);
        fprintf(output, "return");
        if (ret->expr) {
            fprintf(output, " ");
            emit_c_for_expr(ret->expr);
        }
    } break;
    case Node_USING: return;
    default: assert(false);
    }
}

static void emit_c_for_struct(AstStruct *def, char *name) {
    AstBlock *block = (AstBlock *)def->members;
    fprintf(output, "struct");
    if (name) fprintf(output, " %s", name);
    fprintf(output, " {\n");
    for (u64 i = 0; i < block->statements->len; i++) {
        auto var = (AstDecl *)block->statements->nodes[i];
        fprintf(output, "\t");
        emit_c_for_type(var->given_type->resolved_type);
        fprintf(output, " %s;\n", var->name->text);
    }
    fprintf(output, "}");
}

static void emit_c_for_enum(AstEnum *def, char *name) {
    fprintf(output, "enum");
    if (name) fprintf(output, " %s", name);
    fprintf(output, " {\n");
    for (u64 i = 0; i < def->constants->statements->len; i++) {
        AstDecl *decl = (AstDecl *)def->constants->statements->nodes[i];
        fprintf(output, "\t");
        fprintf(output, "%s__%s = %ld", name, decl->name->text, i);
        fprintf(output, ",\n");
    }
    fprintf(output, "}");
}

static void emit_c_for_proc_header(AstProcedure *proc, AstDecl *decl, bool do_names) {
    emit_c_for_type(proc->return_type->resolved_type); // TODO arrays will be emitted as arrays on function signatures
    if (proc->flags & PROC_IS_FOREIGN && proc->foreign_link_name) {
        Token link_name = proc->foreign_link_name->token;
        fprintf(output, " %s(", link_name.text);
    } else {
        if (decl) fprintf(output, " %s(", decl->name->text);
        else fprintf(output, "_lambda_%d", __LINE__);
    }
    if (proc->params) {
        u64 params_length = proc->params->len;
        for (u64 i = 0; i < params_length; i++) {
            AstDecl *p = (AstDecl *)proc->params->nodes[i];
            if (p->flags & DECL_IS_VAR_ARGS) {
                fprintf(output, "...");
                break;
            }

            emit_c_for_type(p->given_type->resolved_type);
            if (do_names) fprintf(output, " %s", p->name->text);

            if (i < params_length-1 || (proc->var_args_index != -1)) {
                fprintf(output, ", ");
            }
        }
    }
    fprintf(output, ")");
}

static void emit_c_for_proc(AstProcedure *proc, bool entry_point, AstDecl *decl) {
    if (entry_point) {
        fprintf(output, "void __compiler_main()");
    } else {
        emit_c_for_proc_header(proc, decl, true);
    }
    fprintf(output, " {\n");
    if (entry_point) {
        fprintf(output, "__global_initializers();\n");
    }
    AstBlock *block = (AstBlock *)proc->block;
    // TODO pre-separate consts from non-consts
    for (u64 i = 0; i < block->statements->len; i++) {
        AstNode *node = block->statements->nodes[i];
        if (node->tag != Node_DECL) continue;
        auto decl = (AstDecl *)node;
        if (!(decl->flags & DECL_IS_CONST)) continue;
        emit_c_for_local_decl(decl);
        // emit_c_for_stmt(node);
        fprintf(output, ";\n");
    }
    for (u64 i = 0; i < block->statements->len; i++) {
        AstNode *node = block->statements->nodes[i];
        if (node->tag == Node_TYPE_DECL) continue;
        if (node->tag == Node_DECL && (((AstDecl *)node)->flags & DECL_IS_CONST)) continue;
        emit_c_for_stmt(node);
        fprintf(output, ";\n");
    }
    emit_deferred_stmts(block);
    fprintf(output, "}\n");
}

static void emit_forward_decls_for_module(Context *ctx, Ast *module, bool main) {
    for (u64 i = 0; i < module->len; i++) {
        AstDecl *decl = (AstDecl *)module->nodes[i];
        if (decl->status == Status_UNRESOLVED) continue; // Don't emit code for unused declarations

        if (decl->tag == Node_TYPE_DECL) {
            char *name = decl->name->text;
            auto typedecl = (AstTypeDecl *)decl;
            if (typedecl->expr_type == TypeDecl_STRUCT) {
                fprintf(output, "struct %s;\n", name);
                fprintf(output, "void __%s_initer(struct %s*);\n", name, name);
            }
            continue;
        }

        if (decl->expr->tag == Node_IMPORT) continue;
        if (decl->expr->tag == Node_LIBRARY) continue;

        if (decl->expr->tag == Node_PROCEDURE) {
            if (main && decl == ctx->decl_for_main) fprintf(output, "void compiler_main()");
            else emit_c_for_proc_header((AstProcedure *)decl->expr, decl, false);
            fprintf(output, ";\n");
            continue;
        }
        emit_c_for_local_decl(decl);
        fprintf(output, ";\n");
    }
    fprintf(output, "\n");
}

static void emit_struct_enum_bodies(Ast *module) {
    for (u64 i = 0; i < module->len; i++) {
        if (module->nodes[i]->tag == Node_IMPORT) continue;

        AstDecl *decl = (AstDecl *)module->nodes[i];
        if (decl->status == Status_UNRESOLVED) continue;
        if (decl->tag == Node_TYPE_DECL) {
            auto type = (AstTypeDecl *)decl;
            if (type->expr_type == TypeDecl_STRUCT) {
                emit_c_for_struct(type->struct_, decl->name->text);
                fprintf(output, ";\n");
            } else if (type->expr_type == TypeDecl_ENUM) {
                emit_c_for_enum(type->enum_, decl->name->text);
                fprintf(output, ";\n");
            }
        }
    }
    fprintf(output, "\n");
}

static void emit_implicit_initers(Ast *module) {
    for (u64 i = 0; i < module->len; i++) {
        AstDecl *decl = (AstDecl *)module->nodes[i];
        if (decl->status == Status_UNRESOLVED) continue;
        if (decl->tag != Node_TYPE_DECL) {
            continue;
        }
        auto def = (AstTypeDecl *)decl;
        if (def->expr_type != TypeDecl_STRUCT) continue;

        char *name = decl->name->text;
        auto members = (AstBlock *)def->struct_->members;
        fprintf(output, "void __%s_initer(struct %s* s) {\n", name, name);
        for (u64 i = 0; i < members->statements->len; i++) {
            auto var = (AstDecl *)members->statements->nodes[i];
            if (!var->expr) continue;
            fprintf(output, "s->%s = ", var->name->text);
            emit_c_for_expr(var->expr);
            fprintf(output, ";\n");
        }
        fprintf(output, "}\n");
    }
    fprintf(output, "\n");
}

static void emit_procedure_bodies(Context *ctx, Ast *module) {
    for (u64 i = 0; i < module->len; i++) {
        if (module->nodes[i]->tag == Node_IMPORT) continue;

        AstDecl *decl = (AstDecl *)module->nodes[i];
        if (decl->tag != Node_DECL) continue;

        // Don't emit code for unused declarations
        if (decl->status == Status_UNRESOLVED) continue;

        if (decl->expr->tag == Node_PROCEDURE) {
            auto proc = (AstProcedure *)decl->expr;
            if (proc->flags & PROC_IS_FOREIGN) continue;
            emit_c_for_proc(proc, (decl == ctx->decl_for_main), decl);
            fprintf(output, "\n");
        }
    }
}
#endif

char *generate_and_write_c_code(Context *ctx, Ast *ast, const char *file_name) {
    const char *postfix = "_generated.c";
    u64 len = strlen(file_name) + strlen(postfix) + 1;
    char *output_file = (char *)malloc(len);
    strcpy(output_file, file_name);
    strcat(output_file, postfix);

    output = fopen(output_file, "w");
    assert(output);

    emit_boilerplate(file_name);

    //
    // Generate struct and enum bodies
    //
    for (s64 i = 0; i < shlen(ctx->modules); i++) {
        emit_struct_enum_bodies(&ctx->modules[i].value->ast);
    }
    emit_struct_enum_bodies(ast);

    //
    // Generate forward decls
    //
    emit_forward_decls_for_module(ctx, ast, true);
    for (s64 i = 0; i < shlen(ctx->modules); i++) {
        emit_forward_decls_for_module(ctx, &ctx->modules[i].value->ast, false);
    }

    //
    // Generate implicit initializers for structs.
    //
    emit_implicit_initers(ast);
    for (s64 i = 0; i < shlen(ctx->modules); i++) {
        emit_implicit_initers(&ctx->modules[i].value->ast);
    }

    //
    // Generate procedure decls
    //
    emit_procedure_bodies(ctx, ast);
    for (s64 i = 0; i < shlen(ctx->modules); i++) {
        emit_procedure_bodies(ctx, &ctx->modules[i].value->ast);
    }

    //
    // Generate initialization code for global variables
    //
    fprintf(output, "void __global_initializers() {\n");
    for (u64 i = 0; i < ast->len; i++) {
        auto decl = (AstDecl *)ast->nodes[i];
        if (decl->tag != Node_DECL) continue;
        if (decl->given_type->resolved_type == ctx->import_type) continue;
        if (!decl->expr) continue;
        if (decl->expr->tag == Node_IDENT) {
            auto ident = (AstIdent *)decl->expr;
            if (ident->resolved_decl->tag == Node_TYPE_DECL)
                continue;
        }
        if (decl->expr->tag == Node_LIBRARY) continue;
        if (decl->expr->tag == Node_PROCEDURE) continue;
        fprintf(output, "%s = ", decl->name->text);
        emit_c_for_expr(decl->expr);
        fprintf(output, ";\n");
    }
    fprintf(output, "}\n");

    fprintf(output, "int main(int __argcount, char *__args[]) {\n");
    fprintf(output, "__compiler_main();\n");
    fprintf(output, "return 0;\n");
    fprintf(output, "}\n");

    fclose(output);
    return output_file;
}
